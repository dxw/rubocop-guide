# Working with Rubocop

This document explains our approach to working with
[Rubocop](https://github.com/bbatsov/rubocop/)
in dxw. We should in general:

### Basics
- use the latest version of rubocop
- configure CI to run rubocop
  - don't modify the `--fail-level` severity: the default behaviour is to fail
    if there are *any* violations and that's what we want
- configure your editor to quickly and loudly complain about rubocop
  violations
  - otherwise it'll fail on CI and you'll feel silly
  - or it'll fail too late and you'll end up re-writing code to make it pass
- use the `.rubocop.yml` file in this repo as a starting point.
- keep the `.rubocop.yml` file in this repo up-to-date with the latest version
  of rubocop

### Exceptions
- avoid adding additional exceptions to the defaults unless there's a really
  good reason.
  - Even if we don't personally like some of the decisions there's value in
    keeping the number of exceptions to the defaults to a minimum.
- consider if any rules we do add should also be added to the default config
  in this repo
  - Differences between projects should be kept to a minimum.

### Todos
- when adding rubocop to a legacy project, it may be pragmatic to generate a
  `.rubocop_todo.yml` file to quickly get rubocop passing
- on projects which have a `.rubocop_yml` from the start, avoid creating a
  todo file: exceptions to rules should instead be handled as described below
- avoid manually editing the `.rubocop_todo.yml`
  - this should be considered an autogenerated file which could be regenerated
    at any point

## Handling exceptions to rules

### Scenario 1: a temporary exclusion

Sometimes we'll need to write some temporary code, or create a complicated bit
of code which we expect to be made simpler by future development. In this case
it's acceptable to generate a `.rubocop_todo.yml` file (see below).

A common example is when controller actions become more complicated and start
exceeding the ABC metric limit, but it's not yet practical to extract business
logic or presentation into objects.

`.rubocop_todo.yml` should be avoided for more permanent exceptions because it
generally excludes the whole file from a particular rule, when actually all we
want is to exclude a single line or single function.

### Scenario 2: a genuine exception

There will inevitably be cases where it is not possible to stick to a rule
without materially making the code more difficult to understand. Examples
include:

- Long regular expressions (violating `Metrics/LineLength`)
- Long case statements (violating `Metrics/MethodLength`

In most cases these should be excluded inline - e.g.

``` ruby
# rubocop:disable Metrics/LineLength
  postcode =~ /^\s*((GIR\s*0AA)|((([A-PR-UWYZ][0-9]{1,2})|(([A-PR-UWYZ][A-HK-Y][0-9]{1,2})|(([A-PR-UWYZ][0-9][A-HJKSTUW])|([A-PR-UWYZ][A-HK-Y][0-9][ABEHMNPRVWXY]))))\s*[0-9][ABD-HJLNP-UW-Z]{2}))\s*$/i
# rubocop:enable Metrics/LineLength
```

This has the downside of adding noise into the application code, but the
advantage that we don't exclude the whole file from the rule, and the risk of
rubocop exceptions persisting after the issue has been resolved (e.g. by code
being deleted) is lower.

### Scenario 3: a false positive, or a Rubocop bug

Sometimes Rubocop will mistakenly apply a rule to some irrelevant code - this
is more of a problem with newer cops. In this case the developer should take a
view on whether to handle this as a temporary exclusion (and generate a todo
file) or as a permanent one (and exclude with an inline comment).

### Scenario 4: other people's code

Any kind of automatically generated code, or code copied from another project
which we don't expect to edit ourselves should not be in the scope of our
rubocop checks.

A common example is config files for gems like rollbar which live in
`config/intializers`.

These can be excluded from specific checks in the main `.rubocop.yml` file, or
if there are multiple failures they can be excluded from all cops.

### Scenario 5: DSLs

Ruby DSLs often make use of `do...end` blocks and so are likely to violate
`Metrics/BlockLength` and possibly `Metrics/BlockNesting`. In our default
`.rubocop.yml` we exclude `config/routes.rb` and all RSpec tests from these
checks. Any additional files written in a DSL should be similarly ignored.

## Adding Rubocop to a legacy project
When applying rubocop to an existing project we're unlikely to be able to
address all the existing issues in one go - the important thing is to
establish standards going forwards.

### 1. Autofix all autofixable issues

Running `rubocop -a` will attempt to automatically fix most style violations.
These changes should be carefully checked: sometimes where the previous
formatting was particularly funky, autofixes can change the meaning of the
code.

For ease of review, this should be committed on its own: it's all
autogenerated code, so the reviewer can concentrate on correctness rather than
specific implementation choices.

### 2. Ignore all remaining issues

Running `rubocop --auto-gen-config` will generate a file called
`.rubocop_todo.yml` containing a set of exceptions to the rules. Adding
`inherit_from: .rubocop_todo.yml` to the top of `.rubocop.yml` will allow
rubocop to pass.

### 3. Accept that we're not going to fix everything

Generally on projects there isn't going to be spare time to go back and
refactor existing code just to ensure that it passes certain Rubocop rules. As
long as all new code passes, we should be satisfied.

### 4. Fix outstanding issues one at at time

Having said that, if we do decide to address a rubocop issue, we should do so
as follows:

1. Delete the rule and watch it fail
2. Refactor the code to make rubocop pass again
3. Commit these changes as one commit

Fixing one rule per commit makes for easier code reviews.
